# Nginx configuration for HTTPS reverse proxy

# SSL settings
ssl_certificate /etc/nginx/certs/local-cert.pem;
ssl_certificate_key /etc/nginx/certs/local-key.pem;

# WebSocket support
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

server {
    listen 80;
    server_name *.lan;
    return 301 https://$host$request_uri;
}

# Directory listing page
server {
    listen 443 ssl;
    server_name raven.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Large file upload support
    client_body_timeout 3600s;
    client_header_timeout 3600s;
    client_max_body_size 10240M;

    # Service status API endpoints (containers, backups, health)
    location /api/ {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $status_backend service-status:80;
        proxy_pass http://$status_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS headers for frontend access
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type' always;

        if ($request_method = 'OPTIONS') {
            return 204;
        }
    }

    # Proxy n8n webhooks through raven.lan to avoid additional SSL cert prompts
    location /webhook/ {
        # Handle preflight OPTIONS requests with all required CORS headers
        if ($request_method = OPTIONS) {
            return 204;
        }

        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $n8n_backend n8n:5678;

        # Increased timeouts for n8n webhooks
        proxy_connect_timeout 600;
        proxy_send_timeout 600;
        proxy_read_timeout 600;
        send_timeout 600;

        # Large file upload support
        proxy_request_buffering off;

        # CORS headers for all responses
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;
        add_header 'Access-Control-Max-Age' '1728000' always;

        proxy_pass http://$n8n_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Serve video transcription files for downloads
    location /videos-to-process/ {
        alias /data/videos-to-process/;
        autoindex off;

        # Set proper MIME types for transcription files
        types {
            text/plain                txt;
            application/x-subrip      srt;
            application/json          json;
        }
        default_type application/octet-stream;

        # Force download with proper filename
        add_header Content-Disposition 'attachment' always;

        # Allow large files
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;

        # Cache control
        expires 1h;
        add_header Cache-Control "public, immutable";
    }

    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
}

# Status Dashboard
server {
    listen 443 ssl;
    server_name traefik.lan;

    # Simple status page
    location / {
        return 200 "HTTPS is working correctly!";
        add_header Content-Type text/plain;
    }

    location /status {
        stub_status on;
        access_log off;
    }
}

# n8n
server {
    listen 443 ssl;
    server_name n8n.lan;

    # Increased timeouts for n8n
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file upload support
    client_body_timeout 3600s;        # Allow 1 hour for upload
    client_header_timeout 3600s;      # Allow 1 hour for headers
    proxy_request_buffering off;      # Don't buffer - stream directly

    # Increase max body size for file uploads (up to 10GB)
    client_max_body_size 10240M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # CORS configuration for webhooks
    location /webhook/ {
        # Hide CORS headers from backend to prevent duplicates
        proxy_hide_header 'Access-Control-Allow-Origin';
        proxy_hide_header 'Access-Control-Allow-Methods';
        proxy_hide_header 'Access-Control-Allow-Headers';
        proxy_hide_header 'Access-Control-Max-Age';

        # Handle preflight OPTIONS requests
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain; charset=utf-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # Add CORS headers to all webhook responses
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;

        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $n8n_backend n8n:5678;
        proxy_pass http://$n8n_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $n8n_backend n8n:5678;
        proxy_pass http://$n8n_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;

        # No health check - standard nginx doesn't support it
    }

    location /maintenance.html {
        return 200 "The n8n service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Open WebUI
server {
    listen 443 ssl;
    server_name openwebui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $openwebui_backend open-webui:8080;
        proxy_pass http://$openwebui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Open WebUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Kokoro
server {
    listen 443 ssl;
    server_name kokoro.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Redirect root to web interface
    location = / {
        return 301 /web/;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $kokoro_backend kokoro-fastapi-gpu:8880;
        proxy_pass http://$kokoro_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Kokoro service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# LM Studio
server {
    listen 443 ssl;
    server_name lmstudio.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://localhost:1234;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The LM Studio service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase
server {
    listen 443 ssl;
    server_name studio.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $supabase_backend supabase-studio:3000;
        proxy_pass http://$supabase_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase API Gateway
server {
    listen 443 ssl;
    server_name supabase.lan;

    # Longer timeouts might be needed depending on API usage
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $kong_backend kong:8000;
        proxy_pass http://$kong_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off; # Important for streaming responses
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase API service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# NocoDB
server {
    listen 443 ssl;
    server_name nocodb.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $nocodb_backend nocodb:8080;
        proxy_pass http://$nocodb_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The NocoDB service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# ComfyUI
server {
    listen 443 ssl;
    server_name comfyui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        # Access ComfyUI directly on port 18188 (configured to listen on 0.0.0.0)
        set $comfyui_backend comfyui:18188;
        proxy_pass http://$comfyui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The ComfyUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# InfiniteTalk API - FastAPI wrapper for video generation (Step 4)
server {
    listen 443 ssl;
    server_name infinitetalk-api.lan;

    # Very long timeouts for video generation (up to 10 minutes)
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $infinitetalk_api_backend infinitetalk-api:8200;
        proxy_pass http://$infinitetalk_api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The InfiniteTalk API service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Crawl4AI
server {
    listen 443 ssl;
    server_name crawl4ai.lan;

    # Longer timeouts might be needed depending on crawl duration
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $crawl4ai_backend crawl4ai:8000;
        proxy_pass http://$crawl4ai_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Crawl4AI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# WhisperX
server {
    listen 443 ssl;
    server_name whisper.lan;

    # Very long timeouts for transcription of long videos
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for large video/audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $whisperx_backend whisperx:8000;
        proxy_pass http://$whisperx_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The WhisperX service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Wan2GP - Multi-Model Video Generation Platform
server {
    listen 443 ssl;
    server_name wan2gp.lan wan.lan;

    # Very long timeouts for video generation (can take several minutes)
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for image/video uploads
    client_max_body_size 500M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $wan2gp_backend wan2gp:7860;
        proxy_pass http://$wan2gp_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Wan2GP Multi-Model Video Generation Platform is starting up. This may take a few minutes to initialize. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Ovi - Audio-Video Generation
server {
    listen 443 ssl;
    server_name ovi.lan;

    # Very long timeouts for video generation (can take several minutes)
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for image uploads in I2V mode
    client_max_body_size 100M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $ovi_backend ovi:7860;
        proxy_pass http://$ovi_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Ovi Audio-Video Generation service is starting up. This may take a few minutes to load the 11B model. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Virtual Assistant - NVIDIA powered visual assistant
server {
    listen 443 ssl;
    server_name va.lan;

    # Longer timeouts for AI processing
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # WebSocket support for real-time video/audio streaming
    location /ws {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $va_backend virtual-assistant-web:8080;
        proxy_pass http://$va_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $va_backend virtual-assistant-web:8080;
        proxy_pass http://$va_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Virtual Assistant service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# InfiniteTalk - Audio-Driven Video Generation for Sparse-Frame Video Dubbing
server {
    listen 443 ssl;
    server_name infinitetalk.lan;

    # Very long timeouts for video generation (can take 10+ minutes for long videos)
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for large video/audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution
        # nginx won't fail at startup if service doesn't exist
        set $infinitetalk_backend infinitetalk:8418;
        proxy_pass http://$infinitetalk_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The InfiniteTalk service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# YouTube Tools - YouTube Tools with WhisperX
server {
    listen 443 ssl;
    server_name yttools.lan;

    # Very long timeouts for download + transcription
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Large audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Gradio UI (main interface)
    location / {
        set $youtube_ui_backend yttools:7860;
        proxy_pass http://$youtube_ui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    # API endpoints (^~ ensures this matches before the / location)
    location ^~ /api/ {
        set $youtube_api_backend yttools:8456;
        proxy_pass http://$youtube_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
    }

    # API documentation endpoints
    location /docs {
        set $youtube_api_backend yttools:8456;
        proxy_pass http://$youtube_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /openapi.json {
        set $youtube_api_backend yttools:8456;
        proxy_pass http://$youtube_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /maintenance.html {
        return 200 "YouTube Tools is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# VibeVoice API - Text-to-Speech with Voice Cloning
server {
    listen 443 ssl;
    server_name vibevoice.lan;

    # Long timeouts for TTS generation (can take several minutes for long text)
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large audio file uploads for voice cloning samples (up to 100MB)
    client_max_body_size 100M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # API endpoints (^~ ensures this matches before the / location)
    location ^~ /api/ {
        set $vibevoice_api_backend vibevoice-api:8100;
        proxy_pass http://$vibevoice_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;

        # CORS headers for API access
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type' always;

        if ($request_method = 'OPTIONS') {
            return 204;
        }
    }

    # API documentation endpoints
    location /docs {
        set $vibevoice_api_backend vibevoice-api:8100;
        proxy_pass http://$vibevoice_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /redoc {
        set $vibevoice_api_backend vibevoice-api:8100;
        proxy_pass http://$vibevoice_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /openapi.json {
        set $vibevoice_api_backend vibevoice-api:8100;
        proxy_pass http://$vibevoice_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Root serves the VibeVoice UI
    location / {
        set $vibevoice_api_backend vibevoice-api:8100;
        proxy_pass http://$vibevoice_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "VibeVoice API is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Emu3 - Multimodal Image Generation with Emu3.5
# Gradio UI + FastAPI for text-to-image, image understanding, and story generation
server {
    listen 443 ssl;
    server_name emu.lan;

    # Long timeouts for image generation (can take several minutes)
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file uploads for image inputs
    client_max_body_size 500M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Main location - serves both Gradio UI and API
    location / {
        # Use variable to force runtime DNS resolution
        # nginx won't fail at startup if service doesn't exist
        set $emu3_backend emu3:8200;
        proxy_pass http://$emu3_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "Emu3 is starting up and loading models. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# YouTube Shorts Generator (existing static page)
server {
    listen 443 ssl;
    server_name shorts.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Proxy API requests (including webhooks) to n8n
    location /api/ {
        set $n8n_backend n8n:5678;

        # Increased timeouts for n8n webhooks
        proxy_connect_timeout 600;
        proxy_send_timeout 600;
        proxy_read_timeout 600;
        send_timeout 600;

        # Large file upload support
        proxy_request_buffering off;

        # Hide CORS headers from backend to prevent duplicates
        proxy_hide_header 'Access-Control-Allow-Origin';
        proxy_hide_header 'Access-Control-Allow-Methods';
        proxy_hide_header 'Access-Control-Allow-Headers';
        proxy_hide_header 'Access-Control-Max-Age';

        # Handle preflight OPTIONS requests
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' '*' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;
            add_header 'Access-Control-Max-Age' '1728000' always;
            add_header 'Content-Type' 'text/plain; charset=utf-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # Add CORS headers to all responses
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;

        # Rewrite /api/webhook/shorts to /webhook/shorts
        rewrite ^/api/(.*)$ /$1 break;

        proxy_pass http://$n8n_backend;
        # Use n8n.lan as Host header so n8n recognizes the webhook
        proxy_set_header Host n8n.lan;
        proxy_set_header X-Forwarded-Proto https;
    }

    location / {
        root /usr/share/nginx/html;
        try_files /shorts.html =404;
    }
}

# Inspirational Shorts Generator - Gradio UI
server {
    listen 443 ssl;
    server_name inspirational-shorts.lan;

    # Long timeouts for generation operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Gradio UI (main interface)
    location / {
        set $shorts_ui_backend shorts-generator:7860;
        proxy_pass http://$shorts_ui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    # API endpoints (^~ ensures this matches before the / location)
    location ^~ /api/ {
        set $shorts_api_backend shorts-generator:8000;
        proxy_pass http://$shorts_api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
    }

    location /maintenance.html {
        return 200 "The Inspirational Shorts Generator is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# NAS - Synology NAS Proxy
server {
    listen 443 ssl;
    server_name nas.lan;

    # Long timeouts for large file operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file upload support
    client_max_body_size 10240M;

    location / {
        proxy_pass http://192.168.3.135:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 504 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The NAS service is unavailable. Please check if the NAS is powered on and accessible.";
        add_header Content-Type text/plain;
    }
}

# UniFi Controller
server {
    listen 443 ssl;
    server_name unifi.lan;

    # Long timeouts for UniFi operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file upload support for firmware updates
    client_max_body_size 500M;

    location / {
        proxy_pass https://192.168.1.1;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;

        # Allow self-signed certificates from UniFi
        proxy_ssl_verify off;

        proxy_intercept_errors on;
        error_page 502 504 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The UniFi Controller is unavailable. Please check if the controller is accessible.";
        add_header Content-Type text/plain;
    }
}
