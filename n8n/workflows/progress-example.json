{
  "nodes": [
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "id-1",
              "name": "researchTopic",
              "value": "={{ $json.chatInput }}",
              "type": "string"
            },
            {
              "id": "id-2",
              "name": "citationFormat",
              "value": "APA",
              "type": "string"
            },
            {
              "id": "id-3",
              "name": "reportDepth",
              "value": "comprehensive",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "51aa1287-abd2-4387-ab6f-de439af6ab5a",
      "name": "Workflow Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -592,
        464
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Single-step property data extraction from Layer 24\n// Combines address matching, FOLIO lookup, and property characteristics in one query\n\nconst inputData = $input.item.json;\nconst citation = inputData._citation;\nconst rawResponse = inputData._raw_response || inputData;\n\n// Extract Address_Original from input data\nconst addressOriginal = inputData.Address_Original || rawResponse.Address_Original;\n\n// Extract reportId and webhook_endpoint from input data\nconst reportId = inputData.reportId || rawResponse.reportId;\nconst webhookEndpoint = inputData.webhook_endpoint || rawResponse.webhook_endpoint;\n\n// Extract features from response\nconst features = rawResponse.features || [];\n\nif (features.length === 0) {\n  return {\n    json: {\n      _type: 'property_data',\n      found: false,\n      address_original: addressOriginal,\n      reportId: reportId,\n      webhook_endpoint: webhookEndpoint,\n      _citation: citation,\n      _provenance: [{\n        field_name: 'property_data',\n        citation_id: citation.citation_id,\n        extraction_method: 'direct_mapping',\n        source_field: 'features[]',\n        confidence_score: 0.5,\n        validation_status: 'missing',\n        notes: 'No matching properties found in Layer 24 response',\n        extracted_at: new Date().toISOString()\n      }]\n    }\n  };\n}\n\n// Get first feature (or implement fuzzy matching logic here if needed)\nconst feature = features[0];\nconst attrs = feature.attributes;\nconst geom = feature.geometry;\n\n// Extract coordinates\nlet lon, lat;\nif (geom.x && geom.y) {\n  lon = geom.x;\n  lat = geom.y;\n} else if (geom.rings && geom.rings[0]) {\n  const ring = geom.rings[0];\n  lon = ring.reduce((sum, p) => sum + p[0], 0) / ring.length;\n  lat = ring.reduce((sum, p) => sum + p[1], 0) / ring.length;\n}\n\n// ===== FIELD MAPPING CONFIGURATION =====\nconst FIELD_MAP = {\n  folio: 'FOLIO',\n  address: 'TRUE_SITE_ADDR',\n  city: 'TRUE_SITE_CITY',\n  zip: 'TRUE_SITE_ZIP_CODE',\n  owner: 'TRUE_OWNER1',\n  condo_flag: 'CONDO_FLAG',\n  parent_folio: 'PARENT_FOLIO',\n  year_built: 'YEAR_BUILT',\n  bedrooms: 'BEDROOM_COUNT',\n  bathrooms: 'BATHROOM_COUNT',\n  half_bathrooms: 'HALF_BATHROOM_COUNT',\n  sqft_heated: 'BUILDING_HEATED_AREA',\n  sqft_actual: 'BUILDING_ACTUAL_AREA',\n  sqft_gross: 'BUILDING_GROSS_AREA',\n  sqft_effective: 'BUILDING_EFFECTIVE_AREA',\n  lot_size: 'LOT_SIZE',\n  dor_code: 'DOR_CODE_CUR',\n  dor_description: 'DOR_DESC',\n  zone: 'PRIMARY_ZONE',\n  subdivision: 'SUBDIVISION',\n  total_value: 'TOTAL_VAL_CUR',\n  land_value: 'LAND_VAL_CUR',\n  building_value: 'BUILDING_VAL_CUR',\n  assessment_year: 'ASSESSMENT_YEAR_CUR'\n};\n\n// Detect if condo\nconst isCondo = attrs[FIELD_MAP.condo_flag] === 'Y' || \n                attrs[FIELD_MAP.dor_description]?.toLowerCase().includes('condo');\n\n// Extract unit from address (Layer 24 stores unit in TRUE_SITE_ADDR)\n// Example: \"1060 BRICKELL AVE 4001\" -> unit is \"4001\"\nconst addressParts = attrs[FIELD_MAP.address]?.trim().split(/\\s+/) || [];\nconst unit = addressParts.length > 3 ? addressParts[addressParts.length - 1] : null;\n\n// Track provenance for all fields\nconst provenanceRecords = [];\n\nfunction validateField(fieldName, fieldValue) {\n  if (fieldValue === null || fieldValue === undefined) {\n    return {\n      confidence_score: 0.5,\n      validation_status: 'missing',\n      notes: 'Field not present in source data'\n    };\n  }\n\n  // Context-aware zero validation for condos\n  const condoZeroFields = ['lot_size', 'land_value', 'building_value'];\n  if (isCondo && fieldValue === 0 && condoZeroFields.some(f => fieldName.toLowerCase().includes(f))) {\n    return {\n      confidence_score: 0.95,\n      validation_status: 'validated',\n      notes: 'Zero is expected for condo properties - no separate land parcel'\n    };\n  }\n\n  return {\n    confidence_score: 0.95,\n    validation_status: 'validated'\n  };\n}\n\nfunction trackField(fieldName, sourceField, value) {\n  const validation = validateField(fieldName, value);\n  provenanceRecords.push({\n    field_name: fieldName,\n    citation_id: citation.citation_id,\n    extraction_method: 'direct_mapping',\n    source_field: sourceField,\n    ...validation,\n    extracted_at: new Date().toISOString()\n  });\n  return value;\n}\n\n// Extract all fields with provenance tracking\nconst extractedData = {\n  _type: 'property_data',\n  found: true,\n\n  // Address & Identification\n  address_original: addressOriginal,\n  folio: trackField('folio', FIELD_MAP.folio, attrs[FIELD_MAP.folio]),\n  address: trackField('address', FIELD_MAP.address, attrs[FIELD_MAP.address]),\n  unit: trackField('unit', 'parsed from TRUE_SITE_ADDR', unit),\n  city: trackField('city', FIELD_MAP.city, attrs[FIELD_MAP.city]),\n  zip: trackField('zip', FIELD_MAP.zip, attrs[FIELD_MAP.zip]),\n  lat: trackField('lat', 'geometry.y or calculated centroid', lat),\n  lon: trackField('lon', 'geometry.x or calculated centroid', lon),\n\n\n  // Ownership\n  owner: trackField('owner', FIELD_MAP.owner, attrs[FIELD_MAP.owner]),\n\n  // Property Type\n  is_condo: isCondo,\n  condo_flag: trackField('condo_flag', FIELD_MAP.condo_flag, attrs[FIELD_MAP.condo_flag]),\n  parent_folio: trackField('parent_folio', FIELD_MAP.parent_folio, attrs[FIELD_MAP.parent_folio]),\n  property_type: trackField('property_type', FIELD_MAP.dor_description, attrs[FIELD_MAP.dor_description]),\n  dor_code: trackField('dor_code', FIELD_MAP.dor_code, attrs[FIELD_MAP.dor_code]),\n\n  // Building Characteristics\n  year_built: trackField('year_built', FIELD_MAP.year_built, attrs[FIELD_MAP.year_built]),\n  bedrooms: trackField('bedrooms', FIELD_MAP.bedrooms, attrs[FIELD_MAP.bedrooms]),\n  bathrooms: trackField('bathrooms', FIELD_MAP.bathrooms, attrs[FIELD_MAP.bathrooms]),\n  half_bathrooms: trackField('half_bathrooms', FIELD_MAP.half_bathrooms, attrs[FIELD_MAP.half_bathrooms]),\n\n  // Square Footage\n  sqft_living: trackField('sqft_living', FIELD_MAP.sqft_heated, attrs[FIELD_MAP.sqft_heated]),\n  sqft_actual: trackField('sqft_actual', FIELD_MAP.sqft_actual, attrs[FIELD_MAP.sqft_actual]),\n  sqft_gross: trackField('sqft_gross', FIELD_MAP.sqft_gross, attrs[FIELD_MAP.sqft_gross] || attrs[FIELD_MAP.sqft_heated]),\n  sqft_effective: trackField('sqft_effective', FIELD_MAP.sqft_effective, attrs[FIELD_MAP.sqft_effective]),\n  lot_size: trackField('lot_size', FIELD_MAP.lot_size, attrs[FIELD_MAP.lot_size] || 0),\n\n  // Zoning & Location\n  zoning: trackField('zoning', FIELD_MAP.zone, attrs[FIELD_MAP.zone]),\n  subdivision: trackField('subdivision', FIELD_MAP.subdivision, attrs[FIELD_MAP.subdivision]),\n\n  // Assessment Values\n  assessed_value: trackField('assessed_value', FIELD_MAP.total_value, attrs[FIELD_MAP.total_value]),\n  assessed_land_value: trackField('assessed_land_value', FIELD_MAP.land_value, attrs[FIELD_MAP.land_value] || 0),\n  assessed_building_value: trackField('assessed_building_value', FIELD_MAP.building_value, attrs[FIELD_MAP.building_value] || 0),\n  assessment_year: trackField('assessment_year', FIELD_MAP.assessment_year, attrs[FIELD_MAP.assessment_year]),\n\n  // Metadata\n  reportId: reportId,\n  webhook_endpoint: webhookEndpoint,\n  _citation: citation,\n  _provenance: provenanceRecords\n};\n\nreturn {\n  json: extractedData,\n};"
      },
      "id": "38dababc-e10f-463b-acf2-063b424917cc",
      "name": "Extract Property Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        464
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "check-features-exist",
              "leftValue": "={{ $json.features[0].attributes.FOLIO }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "dee9dc0b-1541-4af8-90ac-6d3be6fea0fa",
      "name": "Check if Folio Found in Layer ",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1216,
        480
      ]
    },
    {
      "parameters": {
        "url": "https://gisweb.miamidade.gov/arcgis/rest/services/MD_LandInformation/MapServer/24/query",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "where",
              "value": "={{ 'UPPER(TRUE_SITE_ADDR) = UPPER(\\'' + $json.validatedAddress + '\\')' }}"
            },
            {
              "name": "outFields",
              "value": "FOLIO,TRUE_SITE_ADDR,TRUE_SITE_CITY,TRUE_SITE_ZIP_CODE,TRUE_OWNER1,CONDO_FLAG,PARENT_FOLIO,YEAR_BUILT,BEDROOM_COUNT,BATHROOM_COUNT,HALF_BATHROOM_COUNT,BUILDING_HEATED_AREA,BUILDING_ACTUAL_AREA,BUILDING_GROSS_AREA,BUILDING_EFFECTIVE_AREA,LOT_SIZE,DOR_CODE_CUR,DOR_DESC,PRIMARY_ZONE,SUBDIVISION,TOTAL_VAL_CUR,LAND_VAL_CUR,BUILDING_VAL_CUR,ASSESSMENT_YEAR_CUR"
            },
            {
              "name": "returnGeometry",
              "value": "true"
            },
            {
              "name": "outSR",
              "value": "4326"
            },
            {
              "name": "f",
              "value": "json"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "neverError": true,
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "3fcdb8f6-7909-49a8-9d10-2fc68ed86220",
      "name": "Query Property Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1008,
        240
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "address_original",
              "name": "Address_Original",
              "value": "={{ $('Webhook Trigger1').item.json.body.address }}",
              "type": "string"
            },
            {
              "id": "address_full",
              "name": "Address_Full",
              "value": "=",
              "type": "string"
            },
            {
              "id": "address_normalized",
              "name": "Address_Normalized",
              "value": "={{ $('Webhook Trigger1').item.json.body.validatedAddress }}",
              "type": "string"
            },
            {
              "id": "unit",
              "name": "Unit",
              "value": "={{ $('Webhook Trigger1').item.json.body.unitNumber }}",
              "type": "string"
            },
            {
              "id": "zip_code",
              "name": "ZIP_Code",
              "value": "={{ $('Webhook Trigger1').item.json.body.zipCode }}",
              "type": "string"
            },
            {
              "id": "detected_county",
              "name": "Detected_County",
              "value": "={{ $('Webhook Trigger1').item.json.body.detectedCounty }}",
              "type": "string"
            },
            {
              "id": "report_id",
              "name": "reportId",
              "value": "={{ $('Respond with Execution ID').item.json.reportId }}",
              "type": "string"
            },
            {
              "id": "6850c709-b5e4-4cd2-8c6c-f0cec7569bfa",
              "name": "webhook_endpoint",
              "value": "=https://www.condoverify.com/api/n8n/webhook",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "e840e841-2bc3-4fdc-a93f-06aeae3a7ed7",
      "name": "Preserve Input Fields",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -768,
        240
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract and validate the incoming webhook data\nconst body = $input.item.json.body || $input.item.json;\n\n// Validate required fields\nif (!body.address || !body.unitNumber) {\n  throw new Error('Missing required fields: address and unitNumber are required');\n}\n\n// Structure the data for downstream processing\nreturn {\n  address: body.address,\n  validatedAddress: body.validatedAddress,\n  unitNumber: body.unitNumber,\n  city: body.city || null,\n  state: body.state || null,\n  zipCode: body.zipCode || null,\n  forceNew: body.forceNew || false,\n  // Full address for display/search purposes\n  fullAddress: `${body.address}, Unit ${body.unitNumber}${body.city ? ', ' + body.city : ''}${body.state ? ', ' + body.state : ''}${body.zipCode ? ' ' + body.zipCode : ''}`,\n  reportId: `${body.reportId}`\n};"
      },
      "id": "6a593205-d7ce-47bb-a215-d5b2c93b70a2",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -976,
        16
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"xid\": $execution.id } }}",
        "options": {}
      },
      "id": "c84d4eb7-eeff-4a98-b542-bf893755ff7a",
      "name": "Respond with Execution ID",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -768,
        16
      ]
    },
    {
      "parameters": {
        "jsCode": "const httpResponse = $input.first().json;\nconst citationId = `cite-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\nconst timestamp = new Date().toISOString();\n\nconst responseStr = JSON.stringify(httpResponse);\nlet hash = 0;\nfor (let i = 0; i < responseStr.length; i++) {\n  const char = responseStr.charCodeAt(i);\n  hash = ((hash << 5) - hash) + char;\n  hash = hash & hash;\n}\nconst responseHash = `hash-${hash.toString(16).padStart(8, '0').substring(0, 6)}`;\n\nconst citation = {\n  citation_id: citationId,\n  timestamp: timestamp,\n  source_system: \"Miami-Dade County Property Appraiser (Layer 24)\",\n  source_type: \"api\",\n  api_endpoint: {\n    url: \"https://gisweb.miamidade.gov/arcgis/rest/services/MD_LandInformation/MapServer/24/query\",\n    method: \"GET\",\n    params: {}\n  },\n  response_hash: responseHash,\n  http_status: 200,\n  response_time_ms: 0,\n  reliability_score: 0.95\n};\n\nreturn {\n  json: {\n    _citation: citation,\n    _raw_response: httpResponse,\n    ...httpResponse\n  }\n};"
      },
      "id": "e25c1e83-33db-41df-a5d3-72d826771c67",
      "name": "Create Citation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        464
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('set_webhook_endpoint').item.json.webhook_endpoint }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "=  {\n    \"reportId\": \"{{ $('Webhook Trigger1').item.json.body.reportId }}\",\n    \"status\": \"failed\",\n    \"progress\": 0,\n    \"statusMessage\": \"Address validation failed\",\n    \"errorMessage\": \"The address could not be validated. Please check the address and try again.\",\n    \"reportData\": {\n      \"reportId\": \"{{ $('Webhook Trigger1').item.json.body.reportId }}\",\n      \"generatedAt\": \"{{ $now.toISO() }}\",\n      \"reportType\": \"{{ $('Webhook Trigger1').item.json.body.reportType || 'essential' }}\",\n      \"property\": {\n        \"address\": \"{{ $('Webhook Trigger1').item.json.body.address }}\",\n        \"unitNumber\": \"{{ $('Webhook Trigger1').item.json.body.unitNumber }}\"\n      }\n    }\n  }",
        "options": {}
      },
      "id": "c7c87859-0d53-474d-8c3c-e42a6beb9276",
      "name": "Address Failed",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1008,
        656
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert real estate analyst specializing in property intelligence reports.\n\nINPUT: {{ $json.sections.toJsonString() }}\n\nOUTPUT: Generate a JSON object with EXACTLY this structure:\n\n{\n  \"executiveSummary\": \"[2-3 cohesive paragraphs synthesizing the most important findings across all sections. Use markdown formatting for emphasis.]\",\n  \"criticalFindings\": \"- **[Risk Category]**: [Specific finding requiring immediate attention]\\n- **[Risk Category]**: [Specific finding requiring immediate attention]\\n[Continue with 5-8 most critical issues, prioritized by severity. Use markdown formatting with bold categories.]\"\n}\n\nGUIDELINES:\n- Executive Summary: Synthesize cross-cutting themes, not just list sections.\n- Critical Findings: Only include issues that could be deal-breakers or require immediate action (financial red flags, safety concerns, legal issues, major structural problems).\n- Use clear, accessible language - avoid jargon.\n- Be objective and data-driven.\n- Use markdown formatting for emphasis (**, -, etc.) but DO NOT include section headings (## or #) - the UI will provide those.\n\nCRITICAL OUTPUT FORMAT:\n- Output raw JSON starting with {\n- DO NOT wrap in ```json``` or ``` code blocks\n- DO NOT add any text before or after the JSON\n- DO NOT include markdown headings (## or #) in the content\n- The first character of your response must be {\n- The last character of your response must be }\n\nIMPORTANT:\nRemember: Your output helps buyers make one of the biggest financial decisions of their lives. Make it count!\n\nWRONG OUTPUT:\n```json\n{\"executiveSummary\": \"...\", \"criticalFindings\": \"...\"}\n```\n\nWRONG OUTPUT (includes headings):\n{\"executiveSummary\": \"## Executive Summary\\n\\n...\", \"criticalFindings\": \"## Critical Findings\\n\\n...\"}\n\nCORRECT OUTPUT:\n{\"executiveSummary\": \"This property presents a mixed investment profile...\", \"criticalFindings\": \"- **Financial Risk**: ...\"}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        400,
        0
      ],
      "id": "950ecf1d-468c-42b3-b64a-ef6a9144977b",
      "name": "Final Report Compiler"
    },
    {
      "parameters": {
        "options": {
          "reset": false
        }
      },
      "id": "4c7b5ae9-b241-4325-9d54-1f631acf0092",
      "name": "Split In Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -208,
        16
      ]
    },
    {
      "parameters": {
        "jsCode": "// ================================\n// AGGREGATE ALL SECTIONS - FIXED VERSION\n// ================================\n// Read accumulated sections from workflow static data\n\nconst staticData = $getWorkflowStaticData('global');\nconst allSections = staticData.accumulated_sections || [];\n\nconsole.log(`Aggregating ${allSections.length} sections from static data...`);\n\n// Build the complete report structure\nconst reportSections = {};\nconst sectionNames = [];\n\nfor (const item of allSections) {\n  const sectionName = item.section_name;\n  const data = item.data;\n\n  console.log(`Processing section: ${sectionName}`);\n\n  reportSections[sectionName] = data;\n  sectionNames.push(sectionName);\n}\n\nconst sectionsProcessed = sectionNames.length;\n\n// ===== DYNAMIC CRITICAL FINDINGS DETECTION =====\nconst criticalFindings = [];\n\nfunction safeGet(obj, path) {\n  return path.split('.').reduce((current, key) => current?.[key], obj);\n}\n\nfor (const [sectionName, sectionData] of Object.entries(reportSections)) {\n  if (!sectionData || typeof sectionData !== 'object') continue;\n\n  const assessmentAmount = safeGet(sectionData, 'special_assessment_amount') || \n                          safeGet(sectionData, 'specialAssessment.amount');\n  if (assessmentAmount && assessmentAmount > 0) {\n    criticalFindings.push({\n      type: 'special_assessment',\n      severity: 'critical',\n      section: sectionName,\n      message: `Special assessment detected: $${assessmentAmount.toLocaleString()}`,\n      impact: 'high',\n      data: { amount: assessmentAmount }\n    });\n  }\n\n  const financialHealth = safeGet(sectionData, 'financial_health') || \n                         safeGet(sectionData, 'financialHealth.rating');\n  if (financialHealth === 'POOR' || financialHealth === 'poor') {\n    criticalFindings.push({\n      type: 'financial_health',\n      severity: 'high',\n      section: sectionName,\n      message: 'Financial health rated as POOR',\n      impact: 'high'\n    });\n  }\n\n  const hasLitigation = safeGet(sectionData, 'active_litigation') || \n                       safeGet(sectionData, 'litigation.active');\n  if (hasLitigation === true || (Array.isArray(hasLitigation) && hasLitigation.length > 0)) {\n    criticalFindings.push({\n      type: 'litigation',\n      severity: 'high',\n      section: sectionName,\n      message: 'Active litigation detected',\n      impact: 'high'\n    });\n  }\n\n  const insuranceRequired = safeGet(sectionData, 'insurance_required') || \n                           safeGet(sectionData, 'flood_insurance_required');\n  if (insuranceRequired === true) {\n    criticalFindings.push({\n      type: 'insurance_required',\n      severity: 'medium',\n      section: sectionName,\n      message: 'Special insurance required',\n      impact: 'medium'\n    });\n  }\n}\n\nreturn [{\n  json: {\n    sections: reportSections,\n    report_metadata: {\n      generated_at: new Date().toISOString(),\n      sections_processed: sectionsProcessed,\n      section_names: sectionNames,\n      critical_findings_count: criticalFindings.length,\n      processing_method: 'ai_section_by_section'\n    },\n    critical_findings: criticalFindings,\n    alerts: {\n      has_critical_findings: criticalFindings.length > 0,\n      all_sections_present: sectionsProcessed > 0\n    }\n  }\n}];"
      },
      "id": "613b682d-8c42-4ccb-9f6b-848bfe3b5162",
      "name": "Aggregate All Sections",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.webhook_endpoint }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "2ef3e762-85c9-4add-b284-2d298f25d3a1",
      "name": "Complete Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1120,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ================================\n// FORMAT REPORT DATA - DYNAMIC VERSION\n// Purpose: Transform AI-processed sections into final report structure\n// Dynamically adapts to any sections provided\n// ================================\n\n// Get the aggregated sections from the previous node\nconst aggregatedData = $input.first().json;\n\n// Extract the sections and metadata\nconst sections = aggregatedData.sections || {};\nconst reportMetadata = aggregatedData.report_metadata || {};\nconst criticalFindings = aggregatedData.critical_findings || [];\nconst alerts = aggregatedData.alerts || {};\n\n// Get reportId and webhook from various sources\nlet webhookEndpoint = $('Preserve Input Fields').first().json.webhook_endpoint;\nlet reportId = null;\n\n// Try to get reportId from Webhook Trigger\ntry {\n  const webhookTriggerNodes = $('Webhook Trigger1').all();\n  if (webhookTriggerNodes && webhookTriggerNodes.length > 0) {\n    reportId = webhookTriggerNodes[0].json.body?.reportId;\n    console.log('Retrieved reportId from Webhook Trigger:', reportId);\n  }\n} catch (e) {\n  console.log('Could not get reportId from Webhook Trigger:', e.message);\n}\n\n// Try to get webhook endpoint from set_webhook_endpoint node\ntry {\n  const webhookNodes = $('set_webhook_endpoint').all();\n  if (webhookNodes && webhookNodes.length > 0) {\n    webhookEndpoint = webhookNodes[0].json.webhook_endpoint;\n  }\n} catch (e) {\n  console.log('Could not get webhook endpoint from set_webhook_endpoint:', e.message);\n}\n\n// Build the complete report structure\nconst reportData = {\n  // Report metadata\n  reportId: reportId || `report-${Date.now()}`,\n  generatedAt: reportMetadata.generated_at || new Date().toISOString(),\n  reportType: 'comprehensive',\n\n  // Processing metadata from AI sections\n  processingMetadata: {\n    sectionsProcessed: reportMetadata.sections_processed || 0,\n    sectionNames: reportMetadata.section_names || [],\n    processingMethod: reportMetadata.processing_method || 'ai_section_by_section',\n    criticalFindingsCount: criticalFindings.length\n  },\n\n  // Alerts and verification\n  alerts: {\n    hasCriticalFindings: alerts.has_critical_findings || false,\n    allSectionsPresent: alerts.all_sections_present || false\n  },\n\n  // Critical findings summary\n  criticalFindings: criticalFindings,\n\n  // Property overview (use buildingCondition summary if available)\n  propertyInfo: sections.buildingCondition?.summary || sections.buildingCondition || {},\n\n  // All sections - dynamically included\n  sections: sections,\n\n  // Data quality - based on section completion\n  dataQuality: {\n    completeness: {\n      sectionsProcessed: reportMetadata.sections_processed || 0,\n      sectionNames: reportMetadata.section_names || []\n    },\n    hasCriticalData: criticalFindings.length > 0\n  }\n};\n\n// Return the complete webhook payload in the expected format\nreturn {\n  json: {\n    reportId: reportId || reportData.reportId,\n    status: \"completed\",\n    progress: 100,\n    statusMessage: `Report generation complete - ${reportMetadata.sections_processed || 0} sections processed`,\n    reportData: reportData,\n    executionId: $execution.id,\n    webhook_endpoint: webhookEndpoint  // Pass through for Complete Report node\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        0
      ],
      "id": "23bb1c02-ffbf-48b5-8de5-547df580ee0b",
      "name": "Format Report Data"
    },
    {
      "parameters": {},
      "id": "8126823f-f105-4f13-968e-37548cc1a42d",
      "name": "Success",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1280,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ================================\n// MERGE COMPILATION OUTPUT\n// Purpose: Add executive summary and critical findings to sections\n// ================================\n\n// Get the compilation agent output\nconst compilerOutput = $('Final Report Compiler').first().json;\n\n// Get the original aggregated data (before compilation)\nconst originalData = $('Aggregate All Sections').first().json;\n\nconsole.log('Compiler output structure:', JSON.stringify(compilerOutput).substring(0, 200));\n\n// Extract the compilation results\nlet compilationResults;\ntry {\n  // The compiler should output JSON with executiveSummary and criticalFindings\n  let rawOutput;\n\n  if (compilerOutput.response && compilerOutput.response.generations) {\n    rawOutput = compilerOutput.response.generations[0][0].text;\n  } else if (compilerOutput.output) {\n    rawOutput = typeof compilerOutput.output === 'string'\n      ? compilerOutput.output\n      : JSON.stringify(compilerOutput.output);\n  } else {\n    rawOutput = JSON.stringify(compilerOutput);\n  }\n\n  // Strip markdown code blocks if present (defensive parsing for AI output)\n  let jsonString = rawOutput.trim();\n  if (jsonString.startsWith('```')) {\n    console.log('Detected markdown code block wrapper - stripping...');\n    // Remove opening ```json or ``` and closing ```\n    jsonString = jsonString\n      .replace(/^```(?:json)?\\s*/i, '')  // Remove opening marker\n      .replace(/\\s*```\\s*$/i, '');        // Remove closing marker\n    console.log('Stripped JSON preview:', jsonString.substring(0, 100));\n  }\n\n  compilationResults = JSON.parse(jsonString);\n  console.log('Successfully parsed compilation results:', {\n    hasExecutiveSummary: !!compilationResults.executiveSummary,\n    hasCriticalFindings: !!compilationResults.criticalFindings\n  });\n} catch (e) {\n  console.error('Error parsing compilation results:', e.message);\n  console.error('Raw output:', JSON.stringify(compilerOutput).substring(0, 500));\n  // Fallback: return original data without compilation\n  return { json: originalData };\n}\n\nconsole.log('Compilation results extracted:', {\n  hasExecutiveSummary: !!compilationResults.executiveSummary,\n  hasCriticalFindings: !!compilationResults.criticalFindings\n});\n\n// Merge compilation results with original sections\nconst enhancedSections = {\n  // Add new sections at the beginning\n  executiveSummary: compilationResults.executiveSummary ||\n                    'Executive summary not available.',\n  criticalFindings: compilationResults.criticalFindings ||\n                    'No critical findings identified.',\n\n  // Keep all original sections\n  ...originalData.sections\n};\n\nconsole.log(`Enhanced sections: ${Object.keys(enhancedSections).length} total (added 2 new sections)`);\n\n// Return the enhanced data structure\nreturn {\n  json: {\n    sections: enhancedSections,\n    report_metadata: {\n      ...originalData.report_metadata,\n      has_executive_summary: true,\n      has_critical_findings: true,\n      compilation_completed_at: new Date().toISOString()\n    },\n    critical_findings: originalData.critical_findings,\n    alerts: originalData.alerts\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        0
      ],
      "id": "0370fcf4-e4be-4b91-8c3c-bff2d380744e",
      "name": "Merge Compilation Output"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Preserve Input Fields').first().json.webhook_endpoint }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { reportId: $('Preserve Input Fields').first().json.reportId , status: 'generating', progress: 90, statusMessage: 'Generating Report...' } }}",
        "options": {}
      },
      "id": "8acc76df-e635-43ef-bf63-75cea4cc4cc8",
      "name": "Progress 90%",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// ================================\n// INITIALIZE WORKFLOW STATIC DATA & CREATE SECTIONS\n// ================================\n\nconst inputData = $input.first().json;\nconst address = inputData.address_original;\nconst unit = $input.first().json.unit;\nconst reportId = inputData.reportId;\nconst webhookEndpoint = inputData.webhook_endpoint;\n\n// CRITICAL: Initialize workflow static data for accumulation\nconst staticData = $getWorkflowStaticData('global');\nstaticData.accumulated_sections = [];\nconsole.log('Initialized workflow static data for section accumulation');\n\nconst sections = [\n  {\n    sectionName: 'buildingCondition',\n    sectionDescription: 'Building Condition & Maintenance',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'amenities',\n    sectionDescription: 'Amenities & Community Features',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'neighborhood',\n    sectionDescription: 'Neighborhood & Location Analysis',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'parking',\n    sectionDescription: 'Parking, Transportation & Accessibility',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'marketAnalysis',\n    sectionDescription: 'Market Analysis & Comparables',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'financialHealth',\n    sectionDescription: 'Financial Health & HOA Assessments',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'statutorySafety',\n    sectionDescription: 'Statutory Safety & Structural Compliance',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'hoaGovernance',\n    sectionDescription: 'HOA Governance & Management',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'litigation',\n    sectionDescription: 'Litigation, Insurance Claims & Legal',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'climateResilience',\n    sectionDescription: 'Climate Resilience & Environmental Risk',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'rentalRestrictions',\n    sectionDescription: 'Rental Restrictions & Investment',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'insurance',\n    sectionDescription: 'Insurance & Disaster Preparedness',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'financing',\n    sectionDescription: 'Financing & Agency Warrantability',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  },\n  {\n    sectionName: 'publicRecords',\n    sectionDescription: 'Public Records & Corporate Documentation',\n    reportId,\n    webhook_endpoint: webhookEndpoint,\n    address: address,\n    unit: unit\n  }\n];\n\n\n// Return multiple items - one for each section\nreturn sections.map(section => ({ json: section }));"
      },
      "id": "d77f2840-abbf-4280-b597-241e10fc117e",
      "name": "Create Research Sections Array",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        16
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-report",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "cf2949bd-9014-475d-90e8-15c39226d071",
      "name": "Webhook Trigger1",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1168,
        16
      ],
      "webhookId": "7a9c56bd-ab31-4845-9377-0f47d410d397"
    }
  ],
  "connections": {
    "Workflow Configuration": {
      "main": [
        [
          {
            "node": "Create Research Sections Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Property Data": {
      "main": [
        [
          {
            "node": "Workflow Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Folio Found in Layer ": {
      "main": [
        [
          {
            "node": "Create Citation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Address Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query Property Data": {
      "main": [
        [
          {
            "node": "Preserve Input Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve Input Fields": {
      "main": [
        [
          {
            "node": "Check if Folio Found in Layer ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Respond with Execution ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond with Execution ID": {
      "main": [
        [
          {
            "node": "Query Property Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Citation": {
      "main": [
        [
          {
            "node": "Extract Property Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Final Report Compiler": {
      "main": [
        [
          {
            "node": "Merge Compilation Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split In Batches": {
      "main": [
        [
          {
            "node": "Progress 90%",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Aggregate All Sections": {
      "main": [
        [
          {
            "node": "Final Report Compiler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Complete Report": {
      "main": [
        [
          {
            "node": "Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Report Data": {
      "main": [
        [
          {
            "node": "Complete Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Compilation Output": {
      "main": [
        [
          {
            "node": "Format Report Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Progress 90%": {
      "main": [
        [
          {
            "node": "Aggregate All Sections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Research Sections Array": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger1": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "99ff97a0c56026a2c1b3a849547491eb857e68a0b770f2b7c6688eea83f57eda"
  }
}